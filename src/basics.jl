# using Yao
# using YaoPlots
# using Plots

# |0> = [1. + 0im, 0. + 0im]
# |1> = [0. + 0im, 1. + 0im]
# |+> = (|0> + |1>) / ‚àö2 == [1/‚àö2 + 0im, 1/‚àö2 + 0im]
# |_> = (|0> - |1>) / ‚àö2 == [1/‚àö2 + 0im,-1/‚àö2 + 0im]

# X * |0> == |1>
# H * |0> == |+>
# H * |1> == |_>

# A state |œà> == Œ±|0> + Œ≤|1> == 1
# probability == |œà|¬≤

# Hadamard
# H(Œ±|0> + Œ≤|1>) = Œ±/‚àö2(Œ±|0> + Œ≤|1>) + Œ≤/‚àö2(Œ±|0> - Œ≤|1>)
#                = (Œ±+Œ≤)/‚àö2  * (|0>) + (Œ±-Œ≤)/‚àö2  * (|1>)

# circuit = zero_state(1, nbatch=2)
# circuit = circuit |> put(1, 1=>H)
# circuit.state

id =  [1 0
       0 1]

œÉ‚Çì =  [0 1
      1 0]

œÉ·µß = [0 -im
     im  0]

œÉùëß =  [1  0
      0 -1]

S = [1  0
     0 im]

T = ‚àöS        #[1 0
              # 0 ‚ÑØ^(im*(œÄ/4))]

H = (1/‚àö2) * [1  1
              1 -1] .+ 0im

RX = [cos(1/2)    -sin(1/2)im
     -sin(1/2)im   cos(1/2)]

RY = [cos(1/2) -sin(1/2)
      sin(1/2)  cos(1/2)]

RZ = [‚ÑØ^(1/2im)  0
      0          ‚ÑØ^(1/2im)]

cx =  [1 0 0 0
       0 1 0 0
       0 0 0 1
       0 0 1 0]

cy =  [1   0   0   0
       0   1   0   0
       0   0   0  -im
       0   0   im  0]

cz =  [1  0  0  0
       0  1  0  0
       0  0  1  0
       0  0  0 -1]

swap = [1 0 0 0
        0 0 1 0
        0 1 0 0
        0 0 0 1]

ising = [cos(1)    0        0       -im*sin(1)
         0         cos(1)  -sin(1)im 0
         0        -sin(1)im cos(1)   0
        -sin(1)im  0        0        cos(1)]

ccX =  [1 0 0 0 0 0 0 0
        0 1 0 0 0 0 0 0
        0 0 1 0 0 0 0 0
        0 0 0 1 0 0 0 0
        0 0 0 0 1 0 0 0
        0 0 0 0 0 1 0 0
        0 0 0 0 0 0 0 1
        0 0 0 0 0 0 1 0]

cswap = [1 0 0 0 0 0 0 0
         0 1 0 0 0 0 0 0
         0 0 1 0 0 0 0 0
         0 0 0 1 0 0 0 0
         0 0 0 0 1 0 0 0
         0 0 0 0 0 0 1 0
         0 0 0 0 0 1 0 0
         0 0 0 0 0 0 0 1]

bell = cx * (H ‚äó id)

invbell = (H ‚äó id) * cx

rotationX(Œ∏) = [cos(Œ∏/2)   -sin(Œ∏/2)im
               -sin(Œ∏/2)im  cos(Œ∏/2)]
rotationX(x, Œ∏) = rotationX(Œ∏) * x

rotationY(Œ∏) = [cos(Œ∏/2) -sin(Œ∏/2)
                sin(Œ∏/2)  cos(Œ∏/2)]
rotationY(x, Œ∏) = rotationY(Œ∏) * x

rotationZ(Œ∏) = [‚ÑØ^(Œ∏/2im) 0
                0        ‚ÑØ^(Œ∏/2im)]
rotationZ(x, Œ∏) = rotationZ(Œ∏) * x

phase_shift(Œ∏) = [1 0
                 0 ‚ÑØ^(Œ∏*im)]
phase_shift(x, Œ∏) = phase_shift(Œ∏) * x

œÜ0 = [1. + 0im, 0. + 0im]
œÜ1 = [0. + 0im, 1. + 0im]
œÜx = [1/‚àö2 + 0im, 1/‚àö2 + 0im] # == H * œÜ0
œÜy = [1/‚àö2 + 0im,-1/‚àö2 + 0im] # == H * œÜ1

œÉ‚Çì * œÜ0 == œÜ1
H * œÜ0 == œÜx
H * œÜ1 == (1/‚àö2)*(œÜ0-œÜ1) == œÜy
œÜy == (œÜ0 - œÜ1) / ‚àö2 == [1/‚àö2 + 0im,-1/‚àö2 + 0im]

H * œÜ0
swap * (œÜ1 ‚äó œÜ0)

invbell * bell * (œÜ1 ‚äó œÜ0) ‚âà (œÜ1 ‚äó œÜ0)
